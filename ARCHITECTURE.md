# EverythingAI Node - Architecture Documentation

## 整体设计逻辑

### 1. 为什么需要远程调用？

**问题：**
- Playwright 等外部包体积巨大（浏览器二进制文件可达数GB）
- 不同外部包有不同的系统依赖
- 如果都打包进 n8n 节点，会导致：
  - 包体积过大（几百MB到几GB）
  - 安装时间过长
  - 用户可能不需要所有功能

**解决方案：**
- 将需要特殊环境的包（如 Playwright）放到独立的 Docker 容器中
- n8n 节点通过 RPC 远程调用执行代码
- 用户按需部署不同的 Docker 容器

### 2. 解耦设计

```
┌─────────────────────────────────────────┐
│  n8n EverythingAI Node (本地)           │
│                                         │
│  ┌─────────────────────────────────┐   │
│  │  LLM 代码生成                     │   │
│  │  - 分析用户需求                    │   │
│  │  - 生成 JavaScript 代码           │   │
│  └─────────────────────────────────┘   │
│                                         │
│  ┌─────────────────────────────────┐   │
│  │  执行决策                         │   │
│  │  - 检测代码使用的包                │   │
│  │  - 判断：本地执行 or 远程执行？     │   │
│  └─────────────────────────────────┘   │
│                                         │
│  ┌─────────────────────────────────┐   │
│  │  本地执行 (轻量级包)              │   │
│  │  - cheerio (DOM 解析)            │   │
│  │  - Node.js 内置模块              │   │
│  └─────────────────────────────────┘   │
│                                         │
│  ┌─────────────────────────────────┐   │
│  │  远程执行 (重量级包)              │   │
│  │  - 通过 RPC 发送代码              │   │
│  │  - 等待远程执行结果                │   │
│  └─────────────────────────────────┘   │
└──────────────┬────────────────────────┘
               │
               │ RPC (dnode) over TCP
               │ tcp://host:port
               │
               ▼
┌─────────────────────────────────────────┐
│  Docker Container (远程)                 │
│                                         │
│  ┌─────────────────────────────────┐   │
│  │  RPC Server (dnode)              │   │
│  │  - 接收代码                       │   │
│  │  - 执行代码                       │   │
│  │  - 返回结果                       │   │
│  └─────────────────────────────────┘   │
│                                         │
│  ┌─────────────────────────────────┐   │
│  │  Playwright 环境                  │   │
│  │  - Chromium/Firefox/WebKit       │   │
│  │  - 浏览器二进制文件                │   │
│  │  - 系统依赖                        │   │
│  └─────────────────────────────────┘   │
└─────────────────────────────────────────┘
```

### 3. dnode RPC 的作用

**dnode 是什么？**
- Node.js 的 RPC（远程过程调用）库
- 通过 TCP 流实现跨进程/跨网络的函数调用
- 让远程调用看起来像本地函数调用

**为什么选择 dnode？**
1. **简单易用**：API 简洁，易于集成
2. **流式传输**：基于 Node.js Stream，适合传输代码和数据
3. **类型透明**：支持复杂对象和回调函数
4. **轻量级**：依赖少，体积小

**工作流程：**

```
客户端 (n8n 节点)                   服务器 (Docker)
    │                                    │
    ├─ 1. TCP 连接 ────────────────────>│
    │                                    │
    ├─ 2. 发送密码 ────────────────────>│
    │                                    │
    │<─ 3. 认证响应 (OK/AUTH_FAILED) ───┤
    │                                    │
    ├─ 4. 建立 dnode 连接 ──────────────>│
    │                                    │
    ├─ 5. 调用 remote.execute() ───────>│
    │                                    │
    │                                    ├─ 6. 执行代码
    │                                    │
    │<─ 7. 返回结果 ─────────────────────┤
    │                                    │
    ├─ 8. 关闭连接 ─────────────────────>│
```

### 4. 解耦的关键点

**1. 接口标准化**
- 所有外部包都通过相同的 RPC 接口：`execute(code, inputs, callback)`
- 客户端不需要知道具体是哪个包在执行

**2. 独立部署**
- 每个 Docker 容器只包含一个外部包及其依赖
- 可以独立更新、扩展、替换

**3. 配置分离**
- n8n 节点配置：哪些包启用、远程服务器地址
- Docker 容器配置：包版本、系统依赖、环境变量

**4. 协议抽象**
- 使用标准的 RPC 协议（dnode）
- 未来可以替换为其他 RPC 实现（如 gRPC、JSON-RPC）

### 5. 当前实现的问题和改进

**当前问题：**
1. `server.js` 已实现，但需要测试
2. 认证和 RPC 的流切换可能需要优化
3. 错误处理需要更完善

**未来改进方向：**
1. **连接池**：复用 TCP 连接，提高性能
2. **负载均衡**：支持多个 Docker 容器，自动分配负载
3. **健康检查**：定期检查容器状态
4. **日志和监控**：记录执行日志，监控性能
5. **安全增强**：TLS 加密、更严格的认证

### 6. 扩展性

**添加新的外部包：**
1. 创建新的 Docker 容器（如 `external-packages/puppeteer/`）
2. 实现相同的 RPC 接口
3. 在 n8n 节点中添加配置选项
4. 更新 LLM 提示，告知 AI 新包的使用方法

**优势：**
- 不影响现有功能
- 用户可以按需选择部署哪些容器
- 每个容器可以独立优化

## 总结

这个设计实现了：
- ✅ **解耦**：n8n 节点和外部包环境分离
- ✅ **灵活性**：用户可以按需部署不同的 Docker 容器
- ✅ **可扩展性**：易于添加新的外部包支持
- ✅ **性能**：避免在 n8n 节点中安装大型依赖
- ✅ **安全性**：Docker 容器提供隔离环境

